import hou  # pylint: disable=import-error

import baku_modules as bm # pylint: disable=import-error
reload(bm)

EPSILON = bm.EPSILON

# -------------------------------------------------------
# Elements

class Elements():

        def __init__(self, node):
                self.node = node
                self.geo = self.node.node('./RESULT').geometry()

        def transform(self, primnum):
                return self.geo.prim(primnum).fullTransform()

        def setTransform(self, primnum, xform):
                prefix = self._getPrefix(primnum, createNew=True)

                sourceXform = self._sourceTransform(primnum)
                xform = xform * sourceXform.inverted()

                self._setTransformParm(prefix, xform)
                # NOTE: Too heavy so commented out so far
                # self._deleteModIfUnchanged(prefix)

        def instanceIndex(self, primnum):
                prefix = self._getPrefix(primnum)
                if prefix and prefix.startswith('add'):
                        return self.node.parm(prefix + '_instanceindex').eval()
                else:
                        return None

        def setInstanceIndex(self, primnum, index):
                prefix = self._getPrefix(primnum, createNew=True)

                if prefix.startswith('mod'):
                        self.node.parm(prefix + '_instanceindex').set(index)
                        self._deleteModIfUnchanged(prefix)
                else:
                        if index >= 0:
                                self.node.parm(prefix + '_instanceindex').set(index)

        def add(self, xform, instance_index=None):
                index = self.node.parm('add').eval()
                self.node.parm('add').insertMultiParmInstance(index)
                prefix = 'add' + str(index + 1)

                self._setTransformParm(prefix, xform)

                if instance_index != None:
                        self.node.parm(prefix + '_instanceindex').set(instance_index)

                return len(self.geo.prims()) - 1

        def delete(self, prims):
                for primnum in sorted(prims, reverse=True):
                        prefix = self._getPrefix(primnum, createNew=True)
                        if prefix.startswith('mod'):
                                self.node.parm(prefix + '_delete').set(True)
                        else:
                                index = int(prefix[3:]) - 1
                                self.node.parm('add').removeMultiParmInstance(index)

        def _deleteModIfUnchanged(self, prefix):
                delete = self.node.parm(prefix + '_delete').eval()
                if delete == 1:
                        return

                instance_index = self.node.parm(prefix + '_instanceindex').eval()
                if instance_index != -1:
                        return

                trans = self.node.evalParmTuple(prefix + '_trans')
                if abs(trans[0]) > EPSILON or abs(trans[1]) > EPSILON or abs(trans[2]) > EPSILON:
                        return

                rot = self.node.evalParmTuple(prefix + '_rot')
                if abs(rot[0]) > EPSILON or abs(rot[1]) > EPSILON or abs(rot[2]) > EPSILON:
                        return

                scale = self.node.evalParmTuple(prefix + '_scale')
                if abs(scale[0] - 1) > EPSILON or abs(scale[1] - 1) > EPSILON or abs(scale[2] - 1) > EPSILON:
                        return

                index = int(prefix[3:]) - 1
                self.node.parm('mod').removeMultiParmInstance(index)

        def _getPrefix(self, primnum, createNew=False):

                prefix = self.geo.prim(primnum).attribValue('__parm')

                if not prefix and createNew:
                        sectionName = 'mod' if primnum < self._primOffset() else 'add'
                        index = self.node.parm(sectionName).eval()
                        self.node.parm(sectionName).insertMultiParmInstance(index)
                        prefix = sectionName + str(index + 1)

                        if sectionName == 'mod':
                                sourcePrimnum = self.geo.prim(
                                        primnum).intAttribValue('__source_prim')
                                self.node.parm(prefix + '_prim').set(sourcePrimnum)

                return prefix

        def _setTransformParm(self, prefix, xform):
                components = xform.explode()
                trans = components['translate']
                rot = components['rotate']
                scale = components['scale']

                self.node.parmTuple(prefix + '_trans').set(trans)
                self.node.parmTuple(prefix + '_rot').set(rot)
                self.node.parmTuple(prefix + '_scale').set(scale)

        def _sourceTransform(self, primnum):
                sourcePrimnum = self.geo.prim(
                        primnum).intAttribValue('__source_prim')

                if sourcePrimnum >= 0:
                        return self.node.node('./SOURCE').geometry().prim(sourcePrimnum).fullTransform()
                else:
                        return hou.Matrix4(1)

        def _primOffset(self):
                return len(self.node.node('./MODIFIED').geometry().prims())

# -------------------------------------------------------
# State

class ToolType:
        ADD, EDIT = (0, 1)

class TransformMode:
        WHOLE, INDIVIDUAL, TRANSLATE = (0, 1, 2)

class BoundingBoxRange:
        GEOMETRY, ORIGIN = (0, 1)

class State():
        WATCH_PARMS = ('selection', 'tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy', 'sz')

        def __init__(self, state_name, scene_viewer):
                self.state_name = state_name
                self.scene_viewer = scene_viewer

                self.initialized = False

        def initialize(self, kwargs):
                if self.initialized:
                        return
                self.initialized = True

                self.node = kwargs['node']
                self.elements = Elements(self.node)

                # Init bm.Cursor
                self.guide_cursor = hou.GeometryDrawable(
                        self.scene_viewer,
                        geo_type = hou.drawableGeometryType.Line,
                        name = 'cursor',
                        geometry = self.node.node('./ADD_GUIDE').geometry(),
                        params = {
                                'style': hou.drawableGeometryLineStyle.Plain,
                                'highlight_mode': hou.drawableHighlightMode.Matte,
                                'color1': (1, 0, 0, 1)
                        })
                self.guide_cursor.show(True)

                self.cursor = bm.Cursor({
                        'node': self.node,
                        'scene_viewer': self.scene_viewer,
                        'reference_geo': self.node.node('REFERENCE').geometry()
                })

                # Initialize selection
                self._updateSelection(kwargs, None)

                kwargs['state_parms']['tool']['value'] = self.state('last_tool') or 0
                kwargs['state_parms']['xform_mode']['value'] = self.state('last_xform_mode') or TransformMode.WHOLE
                kwargs['state_parms']['bbox_range']['value'] = self.state('last_bbox_range') or 0
                self._onChangeTool(kwargs)
                self.onParmChangeEvent(kwargs)

                # Init pivot cahce
                self._updatePivotCache()

                bm.updateParmCache(self.node, State.WATCH_PARMS)

        def setState(self, key, value):
                self.node.setCachedUserData(key, value)

        def state(self, key):
                return self.node.cachedUserData(key)

        def onCommand(self, kwargs):
                name = kwargs['command']

                if name in ('reset_translate', 'reset_rotate', 'reset_scale'):

                        if name == 'reset_translate':
                                bm.setNodeTransform(self.node, translate=hou.Vector3())

                        elif name == 'reset_rotate':
                                bm.setNodeTransform(self.node, rotate=hou.Vector3())

                        elif name == 'reset_scale':
                                bm.setNodeTransform(self.node, scale=hou.Vector3(1, 1, 1))

                        self._updatePivotCache()
                
                elif name == 'apply_instanceindex':
                        index = self.node.evalParm('instanceindex')

                        for primnum in self.state('selected_prims'):
                                self.elements.setInstanceIndex(primnum, index)
                
                elif name == 'update_input':
                        geo = self.node.node('REFERENCE').geometry()
                        self.cursor.setReferenceGeomtry(geo)


        def _onChangeTool(self, kwargs):
                state_parms = kwargs['state_parms']
                tool = state_parms['tool']['value']

                state_parms['xform_mode']['visible'] = tool == ToolType.EDIT
                state_parms['bbox_range']['visible'] = tool == ToolType.EDIT
                
                self.setState('last_tool', tool)

        def onParmChangeEvent(self, kwargs):
                state_parms = kwargs['state_parms']

                with hou.undos.disabler():
                        xform_mode = state_parms['xform_mode']['value']
                        self.node.parm('xform_mode').set(xform_mode)
                        self.setState('last_xform_mode', xform_mode)

                        bbox_range = state_parms['bbox_range']['value']
                        self.setState('last_bbox_range', bbox_range)

                        self._alignPivot(kwargs)

        def _onNodeParmChange(self, kwargs):

                changed = bm.detectChangedParms(self.node, State.WATCH_PARMS)

                # Side effects
                if 'selection' in changed:
                        selection = changed['selection']['value']
                        self._updateSelection(kwargs,
                                selection, update_parm=False, update_viewer=True)

                if 'tool' in changed:
                        self._updateSelection(kwargs, None)
                        self._onChangeTool(kwargs)

                for key in ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy', 'sz'):
                        if key in changed:
                                # On either transform component has changed
                                xform = bm.getNodeTransform(self.node)
                                self._transformWithPivot(kwargs, xform)
                                break

                if 'attach_to_geo' in changed:
                        if changed['attach_to_geo']['value']:
                                self._updatePivotCache()

        def onEnter(self, kwargs):
                self.initialize(kwargs)

                with hou.undos.disabler():
                        self.node.parm('viewerstate_enabled').set(True)

        def onExit(self, kwargs):
                if self.node:
                        with hou.undos.disabler():
                                self.node.parm('viewerstate_enabled').set(False)

        def onInterrupt(self, kwargs):
                self.guide_cursor.show(False)

        def onResume(self, kwargs):
                self.guide_cursor.show(True)

        def onMousemove(self, kwargs):
                tool = kwargs['state_parms']['tool']['value']

                if tool == ToolType.ADD and self.cursor.snapped == 'reference':
                        rotate = bm.computeDirectionRotates(self.cursor.normal)

                        with hou.undos.disabler():
                                bm.setNodeTransform(self.node, rotate=rotate)

        def _currentCursorXform(self):
                
                rotate = hou.Vector3(self.node.evalParmTuple('r'))
                scale = hou.Vector3(self.node.evalParmTuple('s'))

                return hou.hmath.buildTransform({
                        'translate': self.cursor.position,
                        'rotate': rotate,
                        'scale': scale
                })

        def onMousedown(self, kwargs):
                tool = kwargs['state_parms']['tool']['value']
                device = kwargs['ui_event'].device()

                if tool == ToolType.ADD:
                                xform = self._currentCursorXform()
                                instance_index = self.node.evalParm('instanceindex')

                                with hou.undos.group('Add new instance'):
                                        primnum = self.elements.add(xform, instance_index)
                                        self._updateSelection(kwargs, [primnum])
                
                elif tool == ToolType.EDIT:
                        if device.isLeftButton():
                                self.scene_viewer.triggerStateSelector(hou.triggerSelectorAction.Start, 'select_prims')
                                
                                if device.isShiftKey() or device.isCtrlKey():
                                        existing_selection = self.node.evalParm('selection')
                                        self._updateSelection(kwargs, existing_selection)
                                else:
                                        self._updateSelection(kwargs, None)
        
        def onMousedrag(self, kwargs):
                pass

        def onMouseup(self, kwargs):
                pass

        def onMouseEvent(self, kwargs):
                ui_event = kwargs['ui_event']
                reason = ui_event.reason()

                self.cursor.update({'ui_event': ui_event})

                # Update status
                xform = hou.hmath.buildTranslate(self.cursor.position)
                self.guide_cursor.setTransform(xform)
                        
                bm.callMouseEvents(self, kwargs)
                
                # Stop select when clicking empty space
                if reason == hou.uiEventReason.Picked and self.scene_viewer.currentStateSelector() == 'select_prims':
                        if len(self.state('selected_prims')) == 0:
                                self._updateSelection(kwargs, None)
                                self.scene_viewer.triggerStateSelector(hou.triggerSelectorAction.Stop, 'select_prims')
                
                return False

        def onKeyEvent(self, kwargs):
                state_parms = kwargs['state_parms']
                device = kwargs['ui_event'].device()

                try:
                        if hou.hotkeys.isKeyMatch(device.keyString(), 'h.pane.gview.handle.edit.pivot_mode'):
                                value = state_parms['pivot_mode']['value']
                                state_parms['pivot_mode']['value'] = 1 - value
                                if value:
                                        self._updatePivotCache()
                                else:
                                        if self._visibleHandle(kwargs) == 'bbox':
                                                self._setVisibleHandle('xform')
                                return True
                except ValueError:
                        pass
                
                return False

        def onSelection(self, kwargs):
                sel = kwargs['selection']
                name = kwargs['name']

                if name == 'select_prims' and len(sel.selections()) > 0:
                        selection = sel.selections()[0]
                        self._updateSelection(kwargs, selection)
                        return True

                return False

        def _updateSelection(self, kwargs, selection=None, update_parm=True, update_viewer=False):

                geo = self.node.geometry()

                if selection == None:
                        selection = ''

                if isinstance(selection, basestring):
                        selection = hou.Selection(self.node.geometry(),
                                                                          hou.geometryType.Primitives, selection)

                elif not isinstance(selection, hou.Selection):
                        prims = [geo.prim(primnum) for primnum in selection]
                        selection = hou.Selection(prims)

                selected_prims = [prim.number() for prim in selection.prims(geo)]
                is_selected = len(selected_prims) > 0
                selection_string = selection.selectionString(
                        geo, asterisk_to_select_all=True)

                instanceindex = -1

                if len(selected_prims) > 0:
                        instanceindex = self.elements.instanceIndex(selected_prims[0])

                        for i in xrange(1, len(selected_prims)):
                                if instanceindex != self.elements.instanceIndex(selected_prims[i]):
                                        instanceindex = -1
                                        break

                with hou.undos.group('Select primitives' if is_selected else 'Clear selection'):

                        self.setState('selected_prims', selected_prims)
                        self.setState('cache_selection', selection_string)

                        if update_parm:
                                self.node.parm('selection').set(selection_string)

                        self.node.parm('instanceindex').set(instanceindex)

                        self._alignPivot(kwargs)

                        if update_viewer and self.scene_viewer.currentGeometrySelection() != None:
                                self.scene_viewer.setCurrentGeometrySelection(
                                        hou.geometryType.Primitives, (self.node,), (selection,))

                        visible_handle = self._visibleHandle(kwargs)
                        self._setVisibleHandle(visible_handle)

        def onDraw(self, kwargs):
                draw_handle = kwargs['draw_handle']
                tool = kwargs['state_parms']['tool']['value']

                if tool == ToolType.ADD:
                        cursor_xform = self._currentCursorXform()
                        xform = self.cursor.computeDrawableXform(cursor_xform)

                        self.guide_cursor.setTransform(xform)
                        self.guide_cursor.setGeometry(self.node.node('./ADD_GUIDE').geometry())
                        
                        self.guide_cursor.draw(draw_handle)

        def _visibleHandle(self, kwargs):
                selected_prims = self.state('selected_prims')
                num_selected = len(selected_prims)

                xform_mode = kwargs['state_parms']['xform_mode']['value']

                if num_selected == 0:
                        return None
                elif num_selected == 1:
                        return 'xform'
                else:
                        if xform_mode == TransformMode.INDIVIDUAL:
                                return 'xform'
                        else:
                                return 'bbox'

        def _setVisibleHandle(self, name):
                self.scene_viewer.showHandle('xform', name == 'xform')
                self.scene_viewer.showHandle('bbox', name == 'bbox')


        def _alignPivot(self, kwargs):
                state_parms = kwargs['state_parms']
                selected_prims = self.state('selected_prims')
                num_selected = len(selected_prims)

                xform = None

                if num_selected == 1:
                        xform = self.elements.transform(selected_prims[0])
                else:
                        xform_mode = state_parms['xform_mode']['value']
                        bbox_range = state_parms['bbox_range']['value']

                        selection_pattern = self.node.evalParm('selection')

                        geo = self.node.geometry()
                        if bbox_range == BoundingBoxRange.GEOMETRY:
                                bbox = geo.primBoundingBox(selection_pattern)
                        else:
                                bbox = geo.pointBoundingBox(selection_pattern)
                        
                        scale = hou.Vector3(1, 1, 1)
                        if xform_mode == TransformMode.WHOLE:
                                scale = bbox.sizevec()

                        xform = hou.hmath.buildTransform({
                                'translate': bbox.center(),
                                'scale': scale})
                        
                # Update interface
                bm.setNodeTransform(self.node, xform=xform)
                self._updatePivotCache(xform)
                
                # Toggle handles' visibility
                visible_handle = self._visibleHandle(kwargs)
                self._setVisibleHandle(visible_handle)

        def _updatePivotCache(self, pivot_xform=None):

                if pivot_xform == None:
                        pivot_xform = bm.getNodeTransform(self.node)

                selection = self.state('selected_prims')
                xforms = [self.elements.transform(primnum)
                                  for primnum in selection]
                self.setState('selection_xforms', xforms)
                self.setState('pivot_orig_xform', pivot_xform)

        def _transformWithPivot(self, kwargs, pivot_xform):
                state_parms = kwargs['state_parms']

                if state_parms['pivot_mode']['value']:
                        return

                pivot_orig_xform = self.state('pivot_orig_xform')
                xform_delta = bm.computeDeltaXform(pivot_orig_xform, pivot_xform)

                xform_mode = state_parms['xform_mode']['value']

                if xform_mode == TransformMode.INDIVIDUAL:
                        xform_delta.setAt(3, 0, 0)
                        xform_delta.setAt(3, 1, 0)
                        xform_delta.setAt(3, 2, 0)

                selection = self.state('selected_prims')
                xforms = self.state('selection_xforms')

                for (i, primnum) in enumerate(selection):
                        xform = xforms[i]

                        if xform_mode == TransformMode.INDIVIDUAL:
                                xform = hou.Matrix4(xform.asTuple())
                                t = xform.extractTranslates()
                                xform.setAt(3, 0, 0)
                                xform.setAt(3, 1, 0)
                                xform.setAt(3, 2, 0)
                                xform *= xform_delta
                                xform.setAt(3, 0, t[0])
                                xform.setAt(3, 1, t[1])
                                xform.setAt(3, 2, t[2])
                        elif xform_mode == TransformMode.TRANSLATE:
                                t = (xform * xform_delta).extractTranslates()
                                xform = hou.Matrix4(xform.asTuple())
                                xform.setAt(3, 0, t[0])
                                xform.setAt(3, 1, t[1])
                                xform.setAt(3, 2, t[2])
                        else:
                                xform = xform * xform_delta

                        self.elements.setTransform(primnum, xform)

        def onHandleToState(self, kwargs):
                reason = kwargs['ui_event'].reason()
                handle = kwargs['handle']

                if handle in ('xform', 'bbox'):

                        parms = kwargs['parms']

                        components = bm.getHandleTRS(parms)
                        handle_xform = hou.hmath.buildTransform(components)

                        translate = components['translate']
                        rotate = components['rotate']
                        scale = components['scale']
                        
                        if handle == 'bbox':
                                # Not to hide the handle at the inappropreate timing
                                parms['onoff'] = self._visibleHandle(kwargs) == 'bbox'

                        if reason == hou.uiEventReason.Start:
                                self.scene_viewer.beginStateUndo('Transform elements')
                                self._updatePivotCache(handle_xform)
                                self.guide_cursor.show(False)

                        bm.setNodeTransform(self.node, translate=translate, rotate=rotate, scale=scale)

                        if reason == hou.uiEventReason.Active:
                                self._transformWithPivot(kwargs, handle_xform)

                        if reason == hou.uiEventReason.Changed:
                                self._updatePivotCache(handle_xform)
                                self.guide_cursor.show(True)
                                self.scene_viewer.endStateUndo()

        def onStateToHandle(self, kwargs):

                self.initialize(kwargs)

                handle = kwargs['handle']

                if handle in ('xform', 'bbox'):
                        parms = kwargs['parms']
                        
                        translate = self.node.evalParmTuple('t')
                        rotate = self.node.evalParmTuple('r')
                        scale = self.node.evalParmTuple('s')

                        bm.setHandleTransform(parms, translate=translate, rotate=rotate, scale=scale)
                
                elif handle == 'do_not_hide':
                        self._onNodeParmChange(kwargs)

        def onMenuPreOpen(self, kwargs):

                menu_id = kwargs['menu']
                menu_item_states = kwargs['menu_item_states']

                if menu_id == self.node.type().name() + '_menu':  # Root

                        num_selected = len(self.state('selected_prims'))

                        menu_item_states['delete']['enable'] = num_selected > 0
                        menu_item_states['duplicate']['enable'] = num_selected > 0

        def onMenuAction(self, kwargs):
                item = kwargs['menu_item']
                state_parms = kwargs['state_parms']

                if item == 'toggle_tool':
                        tool = state_parms['tool']['value']
                        state_parms['tool']['value'] = ToolType.ADD if tool == ToolType.EDIT else ToolType.EDIT
                        self._onChangeTool(kwargs)

                elif item == 'delete':
                        with hou.undos.group('Delete Primitives'):
                                selection = self.state('selected_prims')
                                self.elements.delete(selection)
                                self.node.parm('selection').set('')

                elif item == 'duplicate':
                        with hou.undos.group('Duplicate Primitives'):
                                for primnum in self.state('selected_prims'):
                                        xform = self.elements.transform(primnum)
                                        instance_index = self.elements.instanceIndex(primnum)
                                        self.elements.add(xform, instance_index)

                elif item == 'move_pivot':
                        with hou.undos.group('Move Pivot'):
                                bm.setNodeTransform(self.node, translate=self.cursor.position)
                                self._updatePivotCache()

                elif item == 'orient_pivot':
                        with hou.undos.group('Orient Pivot'):
                                origin = hou.Vector3(self.node.parmTuple('t').eval())
                                target = self.cursor.position

                                direction = (target - origin).normalized()  # Direction
                                rotate = bm.computeDirectionRotates(direction)

                                bm.setNodeTransform(self.node, rotate=rotate)
                                self._updatePivotCache()
# -------------------------------------------------------
# Menu

def createMenu():
        nodetype = kwargs['type']

        type_description = nodetype.description()

        keyContext = "h.pane.gview.state.sop.%s" % nodetype.name()
        hou.hotkeys.addContext(
                keyContext, type_description,
                type_description
        )

        # Build the menu
        menu = hou.ViewerStateMenu('%s_menu' % nodetype.name(), type_description)

        hotkey = keyContext + '.switch_tool'
        description = "Switch Tool"
        hou.hotkeys.addCommand(hotkey, description, description, "V")
        menu.addActionItem('toggle_tool', 'Toggle Tool', hotkey)

        hotkey = keyContext + '.delete'
        description = "Delete Selected Primitives"
        hou.hotkeys.addCommand(hotkey, description, description, ("Backspace",))
        menu.addActionItem('delete', description, hotkey)

        hotkey = keyContext + '.duplicate'
        description = "Duplicate Selected Primitives"
        hou.hotkeys.addCommand(hotkey, description, description, ("Ctrl+D",))
        menu.addActionItem('duplicate', description, hotkey)

        menu.addActionItem('move_pivot', 'Move Pivot to Here')
        menu.addActionItem('orient_pivot', 'Orient Pivot to Here')

        return menu
        
# -------------------------------------------------------
# Initialize

def createViewerStateTemplate():
        # Grab a reference to the asset's node type
        nodetype = kwargs['type']

        # Use the node's name and label as the state name and label
        state_name = nodetype.definition().sections()['DefaultState'].contents()
        label = nodetype.description()
        category = nodetype.category()
        # Instantiate ViewerStateTemplate with the state name, label,
        # and node type category
        template = hou.ViewerStateTemplate(state_name, label, category)

        # Mandatory binding
        template.bindFactory(State)
        template.bindIcon(nodetype.icon())

        template.bindGeometrySelector(
                name='select_prims',
                ordered=True,
                prompt='Select Packed Primitive',
                geometry_types=(hou.geometryType.Primitives,),
                primitive_types=(hou.primType.PackedGeometry,),
                auto_start=False,
                secure_selection=hou.secureSelectionOption.Off)

                
        template.bindParameter(
                hou.parmTemplateType.Menu,
                name="tool",
                label="Tool",
                menu_items=(
                        ('add', 'Add', 'SOP_pointgenerate'),
                        ('edit', 'Edit', 'SOP_edit')),
                menu_as_button_strip=True)

        template.bindParameter(hou.parmTemplateType.Toggle,
                name="pivot_mode",
                label='Pivot Mode',
                default_value=False)

        # For Edit tool
        template.bindParameter(
                hou.parmTemplateType.Menu,
                name='xform_mode',
                label='Transform Mode',
                menu_items=(
                        ('whole', 'Whole'),
                        ('individual', 'Individual'),
                        ('translate', 'Translate Only')))

        template.bindParameter(
                hou.parmTemplateType.Menu,
                name='bbox_range',
                label='Bounding Box',
                menu_items=(
                        ('geometry', 'Geometry'),
                        ('origin', 'Origin')))

        # Handles
        template.bindHandle('xform', 'xform',
                handle_parms=[
                        'tx', 'ty', 'tz',
                        'rx', 'ry', 'rz',
                        'sx', 'sy', 'sz'
                        ])      
        template.bindHandle('boundingbox', 'bbox')
        template.bindHandle('domain', 'do_not_hide')

        template.bindMenu(createMenu())

        return template
